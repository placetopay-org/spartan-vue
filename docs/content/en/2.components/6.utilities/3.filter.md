---
title: Filter
description: A versatile filter component for building dynamic filter interfaces with multiple field types, operators, and saved filters.
navigation:
  icon: i-lucide-filter
---

::component-status
::

# Usage

The `SFilter` component allows you to build dynamic filter interfaces. Users can add, configure, and apply filters on different fields using various operators and input types.

::component-preview{file="SFilter/basic"}
::

## Interfaces

A field can have one or more interfaces. Each interface defines a different way the user can input a filter value.

### oneInput

For fields requiring a single value. Supports text, numbers, dates, and amounts. When `type` is omitted, the input defaults to text.

::component-preview{file="SFilter/one-input"}
::

### twoInputs

For fields requiring a range of values (e.g., date ranges, price ranges).

::component-preview{file="SFilter/two-inputs"}
::

### options

For fields with a predefined set of options. Supports single and multiple selection.

::component-preview{file="SFilter/options"}
::

Options can be objects with `id` and `label`, or simple strings.

### selection

For fields where the user enters their own values as tags. Ideal for keywords, dynamic categories, or any field where the user needs to define custom values.

::component-preview{file="SFilter/selection"}
::

### none

For existence-only checks (no value input needed).

::component-preview{file="SFilter/none"}
::

## Multiple Interfaces

A single field can have multiple interfaces, allowing the user to choose between different input modes depending on the operator.

::component-preview{file="SFilter/multiple-interfaces"}
::

## Custom Operators

You can define custom operators as objects with `id`, `label`, and an optional `tag` (string or function) displayed in the badge.

::component-preview{file="SFilter/custom-operators"}
::

## Permanent Filters

Set `permanent: true` on a field to prevent it from being removed or cleared by the user.

::component-preview{file="SFilter/permanent"}
::

## Hide Buttons

Use `hideApplyButton` and `hideClearButton` to control the visibility of the action buttons.

::component-preview{file="SFilter/hide-buttons"}
::

## Validation

Fields support custom validation through the `validate` function. It receives the current value and operator, and should return an error message string (or `null` if valid). Supports async validation.

```vue
<template>
  <SFilter :fields="fields" @apply="onApply" />
</template>

<script setup lang="ts">
import { SFilter, type TField } from '@placetopay/spartan-vue';

const fields: TField[] = [
  {
    id: 'bin',
    name: 'Card BIN',
    interfaces: {
      oneInput: {
        operators: ['equal'],
      },
    },
    validate: async (value) => {
      const binRegex = /^\d{6}$/;
      return !binRegex.test(value) ? 'BIN must be exactly 6 digits' : null;
    },
  },
  {
    id: 'amount',
    name: 'Amount',
    interfaces: {
      twoInputs: {
        type: 'amount',
        currency: 'USD',
        operators: ['between'],
      },
    },
    validate: (value, operator) => {
      return operator === 'between' && parseFloat(value[0]) > parseFloat(value[1])
        ? 'Min value must be less than max value'
        : null;
    },
  },
];
</script>
```

## Saved Filters

The component supports saving and loading filter configurations through the `saved` prop and the `save`/`load` events.

```vue
<template>
  <SFilter
    :fields="fields"
    :saved="savedFilters"
    @apply="onApply"
    @save="onSave"
    @load="onLoad"
  />
</template>

<script setup lang="ts">
import { ref } from 'vue';
import type { TField, TSaveData } from '@placetopay/spartan-vue';

const savedFilters = ref<TSaveData[]>([]);

const onSave = (data: TSaveData[]) => {
  savedFilters.value = data;
};

const onLoad = (filters: TField[]) => {
  console.log('Loaded filters:', filters);
};
</script>
```

## Exposed Methods

The component exposes `apply` and `clear` methods that can be called via template ref.

```vue
<template>
  <SFilter ref="filterRef" :fields="fields" @apply="onApply" />
  <button @click="filterRef?.apply()">Apply</button>
  <button @click="filterRef?.clear()">Clear</button>
</template>
```

## Operators

### Predefined Operators

| Category | Operators |
|----------|-----------|
| Comparison | `equal`, `notEqual`, `greaterThan`, `greaterThanOrEqual`, `lessThan`, `lessThanOrEqual` |
| Text | `contains`, `notContains`, `startsWith`, `endsWith` |
| Range | `between`, `notBetween` |
| Date | `lastWeek`, `lastMonth`, `lastYear`, `today`, `yesterday` |
| Existence | `exist`, `notExist` |

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `fields` | `TField[]` | - | Array of filterable fields |
| `hideApplyButton` | `boolean` | `false` | Hides the apply button |
| `hideClearButton` | `boolean` | `false` | Hides the clear button |
| `applyWhenClear` | `boolean` | `false` | Automatically applies filters when clearing |
| `immediateApply` | `boolean` | `false` | Applies filters immediately on mount |
| `responsive` | `boolean` | `true` | Controls responsive behavior |
| `saved` | `TSaveData[]` | - | Saved filter configurations. Shows the save button when provided |

## Events

| Event | Payload | Description |
|-------|---------|-------------|
| `apply` | `TField[]` | Emitted when filters are applied. Contains only fields with active state |
| `clear` | `TField[]` | Emitted when filters are cleared |
| `save` | `TSaveData[]` | Emitted when the user saves a filter configuration |
| `load` | `TField[]` | Emitted when a saved filter is loaded |
